# Project Euler

# Problem 61: Cyclical figurate numbers
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate(polygonal) numbers
# and are generated by the following formulae:

# Triangle	 	P3, n = n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4, n = n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5, n = n(3nâˆ’1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6, n = n(2nâˆ’1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7, n = n(5nâˆ’3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8, n = n(3nâˆ’2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next number
# (including the last number with the first).
# Each polygonal type: triangle(P3, 127=8128), square(P4, 91=8281), and pentagonal(P5, 44=2882),
# is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

from itertools import permutations
import time


def is_cyclic(a, b):
    return str(a)[2:] == str(b)[:2]


def find_cycle():
    polygonal_generators = {
        3: lambda n: n * (n + 1) // 2,
        4: lambda n: n * n,
        5: lambda n: n * (3 * n - 1) // 2,
        6: lambda n: n * (2 * n - 1),
        7: lambda n: n * (5 * n - 3) // 2,
        8: lambda n: n * (3 * n - 2),
    }
    polygons = {n: set() for n in polygonal_generators}

    for n in range(1, 200):
        for k in polygonal_generators:
            p = polygonal_generators[k](n)
            if p >= 1000 and p <= 9999:
                polygons[k].add(p)

    for p in permutations(range(3, 9)):
        for a in polygons[p[0]]:
            for b in polygons[p[1]]:
                if not is_cyclic(a, b):
                    continue
                for c in polygons[p[2]]:
                    if not is_cyclic(b, c):
                        continue
                    for d in polygons[p[3]]:
                        if not is_cyclic(c, d):
                            continue
                        for e in polygons[p[4]]:
                            if not is_cyclic(d, e):
                                continue
                            for f in polygons[p[5]]:
                                if not is_cyclic(e, f):
                                    continue
                                if is_cyclic(f, a):
                                    return [a, b, c, d, e, f]


def main():
    start_time = time.time()
    cycle = find_cycle()
    print('Array:', cycle)
    print('Problem 61:', sum(cycle))
    print('Total time: {}'.format(time.time() - start_time))


if __name__ == '__main__':
    main()
